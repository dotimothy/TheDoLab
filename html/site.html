<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TheDoLab Bulk Site Checker Tool</title>
    <!-- Load Tailwind CSS and configure for dark mode -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // Enable dark mode based on the 'dark' class on the HTML tag
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for aesthetic appeal and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        .dark body {
            background-color: #1a202c; /* Dark background */
        }
        .container-card {
            max-width: 95vw;
            width: 600px;
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease-in-out;
        }
        .status-box {
            border-left: 4px solid;
            transition: border-color 0.3s;
        }
        /* Light Mode Colors */
        .status-success { border-color: #10B981; } 
        .status-failure { border-color: #EF4444; } 
        .status-info { border-color: #3B82F6; }
        
        /* Dark Mode Overrides */
        .dark .status-box {
             background-color: #1f2937; /* Darker bg for status box */
        }
        .dark .status-success { border-color: #34D399; } /* Lighter green */
        .dark .status-failure { border-color: #F87171; } /* Lighter red */
        .dark .status-info { border-color: #60A5FA; }    /* Lighter blue */
        
        /* Styling for the clear match result badge */
        .match-badge {
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            line-height: 1rem;
            display: inline-flex;
            align-items: center;
        }
        .match-badge-success { background-color: #D1FAE5; color: #065F46; } /* Tailwind green-100/green-800 */
        .match-badge-failure { background-color: #FEE2E2; color: #991B1B; } /* Tailwind red-100/red-800 */
        .dark .match-badge-success { background-color: #10B981; color: #ECFDF5; } /* Tailwind green-500/green-50 */
        .dark .match-badge-failure { background-color: #F87171; color: #FFF; } /* Tailwind red-400/white */

        .redirect-chain {
            margin-top: 8px;
            padding: 4px 8px;
            border-radius: 6px;
            background-color: #f0f4f8;
            border: 1px solid #e2e8f0;
            color: #475569;
            font-size: 0.75rem;
        }
        .dark .redirect-chain {
            background-color: #374151;
            border: 1px solid #4b5563;
            color: #d1d5db;
        }
        .redirect-chain-item {
            display: block;
            line-height: 1.5;
        }
        .redirect-chain-item span {
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 transition-colors duration-300">

    <!-- Dark Mode Toggle Button -->
    <button id="darkModeToggle" onclick="toggleDarkMode()" 
            class="absolute top-4 right-4 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 
                   transition-colors duration-300 shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
        <!-- Icon will be set by JavaScript -->
    </button>

    <div id="app" class="container-card bg-white dark:bg-gray-800 p-6 md:p-8 rounded-2xl space-y-6 transition-colors duration-300">
        <h1 class="text-3xl font-extrabold text-gray-900 dark:text-white text-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 inline-block text-blue-600 mr-2 -mt-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>
            TheDoLab Bulk Site Checker Tool
        </h1>
        <p class="text-sm text-gray-500 dark:text-gray-400 text-center">
            Compares your public IPv4 against a fixed list of domains using **Google DNS-over-HTTPS (DoH)**, with full **CNAME chain detection**.
        </p>

        <!-- DNS Resolver Configuration (Fixed to Google DoH) -->
        <div class="border border-gray-200 dark:border-gray-700 p-4 rounded-lg space-y-3">
            <label class="block text-sm font-semibold text-gray-700 dark:text-gray-300">DNS Resolution Method (Fixed):</label>
            <div class="flex flex-col space-y-2">
                
                <!-- Google Option (DoH) - Now the only option -->
                <div class="flex items-center p-2 rounded-lg bg-gray-50 dark:bg-gray-700">
                    <input type="radio" name="dnsResolver" value="google" checked class="form-radio h-4 w-4 text-blue-600 transition duration-150 ease-in-out pointer-events-none">
                    <span class="ml-2 text-sm font-medium text-gray-700 dark:text-gray-300">Google (8.8.8.8 DoH) - Explicit CNAME/A Check</span>
                </div>
            </div>
        </div>


        <!-- User IP Display -->
        <div class="bg-blue-100 dark:bg-blue-900 p-3 rounded-lg text-center shadow-inner">
            <p class="text-sm font-semibold text-blue-800 dark:text-blue-200">Your Public IP Address:</p>
            <p id="userIpDisplay" class="text-xl font-mono font-bold text-blue-900 dark:text-blue-100 mt-1">Loading...</p>
        </div>

        <!-- Action Button (now a Rerun button) -->
        <button id="checkButton" onclick="runAllChecks()"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-xl transition duration-300 ease-in-out transform hover:scale-[1.01] 
                       focus:outline-none focus:ring-4 focus:ring-blue-300 active:bg-blue-800 shadow-md hover:shadow-lg">
            Rerun All Checks
        </button>

        <!-- Results Display Area -->
        <div id="resultContainer" class="space-y-4 pt-4">
            <h2 class="text-lg font-bold text-gray-900 dark:text-white border-b border-gray-200 dark:border-gray-700 pb-2">Domain Resolution Results</h2>
            <!-- Individual domain results will be inserted here -->
            <div id="resultsList" class="space-y-3">
                <div id="initialStatus" class="p-4 rounded-lg bg-gray-50 dark:bg-gray-700 text-gray-600 dark:text-gray-300">
                    Press "Rerun All Checks" or wait for the automatic check to complete.
                </div>
            </div>
        </div>
        
        <!-- Disclaimer -->
        <p class="text-xs text-gray-400 dark:text-gray-500 mt-4 text-center">
            *IP resolution uses fixed public APIs: `v4.ident.me` for client IP. Domain resolution uses the selected method.
        </p>

    </div>

    <script>
        // --- Configuration and API Endpoints ---
        const USER_IP_API = 'https://v4.ident.me/';
        const DOH_API_ENDPOINTS = {
            // Only Google DoH remains
            'google': 'https://dns.google/resolve?name=',
        };
        
        const PRELISTED_DOMAINS = [
            'sj.timothydo.me',
            'bdo.timothydo.me',
            'oc.timothydo.me'
        ];
        
        // --- DOM Elements ---
        const checkButton = document.getElementById('checkButton');
        const resultsList = document.getElementById('resultsList');
        const userIpDisplay = document.getElementById('userIpDisplay');

        // --- Helper Functions ---

        function getSelectedResolver() {
            // Hardcoded to return 'google' since it's the only option
            return { 
                value: 'google', 
                name: 'Google (8.8.8.8 DoH)' 
            }; 
        }

        // --- Dark Mode Logic (remains the same) ---
        function setupDarkMode() {
            const html = document.documentElement;
            const isDarkMode = localStorage.getItem('theme') === 'dark' || 
                               (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches);
            
            if (isDarkMode) {
                html.classList.add('dark');
                updateDarkModeToggle(true);
            } else {
                html.classList.remove('dark');
                updateDarkModeToggle(false);
            }
        }

        function toggleDarkMode() {
            const html = document.documentElement;
            const isDark = html.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateDarkModeToggle(isDark);
        }

        function updateDarkModeToggle(isDark) {
            const toggleButton = document.getElementById('darkModeToggle');
            // Sun icon for light mode (when dark mode is OFF)
            // Moon icon for dark mode (when dark mode is ON)
            toggleButton.innerHTML = isDark
                ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M9.52 2.404A1 1 0 0110.15 2h3.7c.334 0 .61.272.63.605.21.348.375.71.493 1.084.58.625.964 1.34 1.138 2.083.178.78.214 1.577.105 2.373a8 8 0 01-1.42 4.095c-.394.757-.905 1.442-1.524 2.022-.619.579-1.332 1.05-2.115 1.393-.783.344-.52-1.614-.52-2.435 0-1.896.79-3.714 2.188-5.084C6.315 4.982 7.797 4.25 9.4 4.195c.29-.009.58-.009.87-.009z" clip-rule="evenodd" /></svg>` 
                : `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.525 3.328a.75.75 0 01.53.22L9.18 5.074a.75.75 0 01-1.06 1.06l-1.125-1.124a.75.75 0 01.53-1.28zM3 10.5a.75.75 0 01.75.75h2.25a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75.75.75 0 01.75-.75zM16.475 3.328a.75.75 0 00-.53.22l-1.125 1.124a.75.75 0 001.06 1.06l1.125-1.124a.75.75 0 00-.53-1.28zM18 11.25a.75.75 0 01.75-.75h2.25a.75.75 0 010 1.5H18.75a.75.75 0 01-.75-.75zM12 18a6 6 0 00-6 6h12a6 6 0 00-6-6zM12 17.25a4.5 4.5 0 110-9 4.5 4.5 0 010 9z"/></svg>` 
        }

        
        /**
         * Sets the loading state on the UI.
         */
        function setLoading(isLoading) {
            checkButton.disabled = isLoading;
            const icon = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>`;

            if (isLoading) {
                checkButton.innerHTML = `<span class="flex items-center justify-center">${icon} Running Checks...</span>`;
                userIpDisplay.innerHTML = `<span class="text-sm flex items-center justify-center text-blue-700 dark:text-blue-300">${icon} Fetching...</span>`;
            } else {
                checkButton.textContent = 'Rerun All Checks';
            }
        }

        /**
         * Generic fetch wrapper with basic error handling and exponential backoff.
         */
        async function robustFetch(url, isText = false, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    if (isText) {
                         return (await response.text()).trim();
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Fetch attempt ${i + 1} failed for ${url}:`, error.message);
                    if (i === retries - 1) throw error; // Re-throw on final failure
                    // Exponential backoff
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 500;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Fetches the user's public IPv4 address using v4.ident.me.
         */
        async function getUserIP() {
            try {
                const ip = await robustFetch(USER_IP_API, true); 
                return ip;
            } catch (error) {
                console.error("Failed to fetch user IP:", error);
                return null;
            }
        }
        
        /**
         * Recursively resolves the CNAME chain until the final A record is found.
         * This function follows the logic:
         * 1. Check explicitly for CNAME (type 5). If found, record it and recurse on the target.
         * 2. If no CNAME, check for the final A record (type 1) (the "nslookup" equivalent).
         * 3. If neither is found, resolution fails.
         * * @returns { ip: string | null, redirects: string[] }
         */
        async function resolveDOHChain(domain, dohApiUrl, redirects = [], attempts = 0) {
            const MAX_ATTEMPTS = 5;
            
            if (attempts >= MAX_ATTEMPTS) {
                console.warn(`Max resolution attempts (${MAX_ATTEMPTS}) reached for ${domain}. Possible loop or deep chain.`);
                return { ip: null, redirects }; 
            }
            
            // --- STEP 1: Explicitly check for CNAME (type 5) ---
            try {
                // Query for type=5 (CNAME)
                const cnameData = await robustFetch(`${dohApiUrl}${domain}&type=5`); 

                if (cnameData && cnameData.Answer) {
                    const cnameRecord = cnameData.Answer.find(record => record.type === 5); // Type 5 is CNAME
                    
                    if (cnameRecord) {
                        // Found a CNAME, follow the chain recursively
                        const target = cnameRecord.data.replace(/\.$/, ''); // Clean trailing dot
                        
                        if (redirects.includes(target)) {
                            console.warn(`CNAME loop detected at ${target}`);
                            return { ip: null, redirects }; 
                        }
                        
                        redirects.push(target);
                        // Recursively call for the next domain in the chain
                        return await resolveDOHChain(target, dohApiUrl, redirects, attempts + 1);
                    }
                }
            } catch (error) {
                console.warn(`Explicit CNAME check failed for ${domain}. Continuing to A record check.`, error);
                // Continue to STEP 2 if CNAME check fails or returns no CNAME
            }
            
            // --- STEP 2: Check for the final A record (type 1) (nslookup equivalent) ---
            // If no CNAME was found in Step 1, this domain should have the final IP.
            try {
                // Query for type=1 (A record)
                const aData = await robustFetch(`${dohApiUrl}${domain}&type=1`); 

                if (aData && aData.Answer) {
                    const aRecord = aData.Answer.find(record => record.type === 1); // Type 1 is A record
                    if (aRecord) {
                        // Found the final IP
                        return { ip: aRecord.data, redirects }; 
                    }
                }

            } catch (error) {
                console.warn(`Final A record check failed for ${domain}.`, error);
                // Continue to failure
            }

            // --- STEP 3: Failure ---
            return { ip: null, redirects };
        }

        /**
         * Fetches the IPv4 address associated with a domain using the selected resolver.
         * Now hardcoded to use Google DoH and the explicit two-step CNAME/A resolution.
         * @returns { domainIP: string | null, redirects: string[] }
         */
        async function getDomainIP(domain) {
            const baseUrl = DOH_API_ENDPOINTS['google'];
            // Use the explicit CNAME chain logic
            const result = await resolveDOHChain(domain, baseUrl);
            return { domainIP: result.ip, redirects: result.redirects };
        }

        /**
         * Main function to coordinate all IP checks and comparisons.
         */
        async function runAllChecks() {
            setLoading(true);
            resultsList.innerHTML = ''; // Clear previous results

            // Resolver is fixed to Google
            const resolver = getSelectedResolver(); 

            // 1. Get User IP (only once)
            const userIP = await getUserIP();
            userIpDisplay.textContent = userIP || 'IP Fetch Failed';

            if (!userIP) {
                resultsList.innerHTML = `<div class="p-4 rounded-lg bg-red-100 dark:bg-red-900 status-failure text-red-800 dark:text-red-200 font-medium">
                    <p>ðŸ›‘ Cannot perform checks: Failed to retrieve your public IPv4 address.</p>
                </div>`;
                setLoading(false);
                return;
            }

            // 2. Run Domain Checks in Parallel
            const checkPromises = PRELISTED_DOMAINS.map(async domain => {
                const resolution = await getDomainIP(domain);
                return {
                    domain: domain,
                    domainIP: resolution.domainIP,
                    redirects: resolution.redirects,
                    isMatch: resolution.domainIP && (resolution.domainIP === userIP),
                    resolved: !!resolution.domainIP
                };
            });

            const allResults = await Promise.all(checkPromises);

            // 3. Render Results
            renderAggregatedResults(userIP, allResults, resolver.name);

            setLoading(false);
        }

        /**
         * Renders the results of all domain checks into the list.
         */
        function renderAggregatedResults(userIP, results, resolverName) {
            resultsList.innerHTML = ''; // Clear the list

            results.forEach(result => {
                const type = result.resolved ? (result.isMatch ? 'success' : 'failure') : 'failure';
                
                let statusText = '';
                let badgeClass = '';
                let details = '';

                if (result.resolved) {
                    if (result.isMatch) {
                        statusText = 'MATCH';
                        details = `Your IP (${userIP}) equals the final resolved IP.`;
                        badgeClass = 'match-badge-success';
                    } else {
                        statusText = 'MISMATCH';
                        details = `Mismatch detected. Likely behind a proxy/CDN.`;
                        badgeClass = 'match-badge-failure';
                    }
                } else {
                    statusText = 'FAILED';
                    details = `Could not resolve IPv4 for this domain using ${resolverName}.`;
                    badgeClass = 'match-badge-failure';
                }
                
                let redirectHtml = '';
                if (result.redirects && result.redirects.length > 0) {
                    // Create the redirection chain visualization
                    const chainItems = result.redirects.map((r, i) => 
                        `<span class="redirect-chain-item font-semibold">${i === 0 ? result.domain : 'CNAME'} &rarr; <span class="font-normal">${r}</span></span>`
                    ).join('');
                    
                    redirectHtml = `
                        <div class="redirect-chain">
                            <strong class="text-xs font-semibold block mb-1">CNAME Redirection Chain (${result.redirects.length} hop${result.redirects.length > 1 ? 's' : ''}):</strong>
                            ${chainItems}
                        </div>
                    `;
                }

                const resultHtml = `
                    <div class="status-box status-${type} p-4 rounded-lg bg-white dark:bg-gray-800 shadow-lg">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center">
                                <span class="text-md font-bold text-gray-900 dark:text-white mr-3">${result.domain}</span>
                                <span class="match-badge ${badgeClass}">${statusText}</span>
                            </div>
                            <span class="text-xs font-semibold text-blue-600 dark:text-blue-400">${resolverName}</span>
                        </div>
                        <div class="text-xs space-y-1 pl-1">
                            <p class="text-gray-700 dark:text-gray-300">
                                <strong>Final Resolved IP:</strong> <span class="font-mono font-bold">${result.domainIP || 'N/A'}</span>
                            </p>
                            <p class="text-gray-600 dark:text-gray-400">${details}</p>
                            ${redirectHtml}
                        </div>
                    </div>
                `;
                resultsList.innerHTML += resultHtml;
            });
        }
        
        // --- Initialization ---
        
        window.onload = function() {
            setupDarkMode();
            // Automatically run the check for all domains upon load
            runAllChecks(); 
        };
    </script>
</body>
</html>
